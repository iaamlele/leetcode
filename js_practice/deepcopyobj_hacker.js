// 缺点:1.数据类型限制.只能处理部分数据类型
//      2.如果对象中存在循环引用，JSON.stringify 会抛出错误。循环引用指的是对象属性直接或间接引用了自身。
//      3.对于大型或复杂的对象，性能可能较差。字符串化和解析整个对象需要时间和内存，特别是当对象结构深且复杂时。例如，对于包含大量嵌套对象的大型对象，序列化和反序列化的时间成本可能会非常高。
// 序列化:将数据结构或对象转换为一种可以存储或传输的格式的过程->JSON.stringify    
// 反序列化:将序列化的数据格式转换回原始的数据结构或对象的过程->JSON.parse
// 深拷贝:深拷贝递归地复制对象的所有属性，包括嵌套对象。深拷贝后的新对象与原对象完全独立，修改新对象不会影响原对象，反之亦然。
// 浅拷贝:浅拷贝只复制对象的第一层属性。如果属性是引用类型（如对象、数组），浅拷贝仅复制引用，而不是复制引用对象本身。因此，浅拷贝后的新对象和原对象共享对同一引用类型的引用。
 
const obj = {
    "lele": 22,
    "haohao": 23,
    "sex": {
        "0": "woman",
        "1": "man"
    }
}

function copyObj(obj) {
    const str = JSON.stringify(obj);
    return JSON.parse(str);
}

const newobj = copyObj(obj);
console.log(newobj);
console.log(obj === newobj);